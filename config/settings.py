"""
Django settings for Kronon project.

Generated by 'django-admin startproject' using Django 6.0.1.
Enhanced for Enterprise Accounting System requirements
"""

import os
from dataclasses import dataclass
from datetime import timedelta
from pathlib import Path
from typing import Any

from django_stubs_ext import monkeypatch as type_hinting_patch
from environ import Env

# Импортируем функции настройки Loguru и Sentry
from config.core.logging import setup_loguru
from config.core.sentry import setup_sentry

# ==============================================================================
# TYPE HINTING PATCH
# ==============================================================================

# Патчим Django с помощью django_stubs_ext
# для поддержки дженериков (ModelAdmin[User] и т.д.) в рантайме
type_hinting_patch()  # Это необходимо для Strict Mypy режима


# ==============================================================================
# ENVIRONMENT CONFIGURATION
# ==============================================================================

# Путь к корневой директории проекта
BASE_DIR = Path(__file__).resolve().parent.parent

# Инициализация обработки переменных окружения
env = Env()

# Чтение .env файла (ищем .env файл в корне проекта)
READ_DOT_ENV_FILE: bool = env.bool("DJANGO_READ_DOT_ENV_FILE", default=True)

if READ_DOT_ENV_FILE:
    env_file: Path = BASE_DIR / ".env"

    if env_file.exists():
        Env.read_env(env_file)


# ==============================================================================
# CORE SETTINGS
# ==============================================================================

# Секретный ключ для подписи сессий и токенов
SECRET_KEY: str = env.str("SECRET_KEY")

# debug-режим
DEBUG: bool = env.bool("DEBUG", default=False)

# Список хостов, которым разрешено обращаться к приложению
ALLOWED_HOSTS: list[str] = env.list(
    "ALLOWED_HOSTS",
    default=["localhost", "127.0.0.1"],
)

# --- CORS (Cross-Origin Resource Sharing) ---
# Список хостов фронтенда, которым разрешено обращаться к приложению (React на порту `5173`)
CORS_ALLOWED_ORIGINS: list[str] = env.list(
    "CORS_ALLOWED_ORIGINS",
    default=["http://localhost:5173", "http://127.0.0.1:5173"],
)
# Разрешаем Cookie/Credentials (важно для авторизации)
CORS_ALLOW_CREDENTIALS = True

# --- Настройки прокси (Nginx) ---
# Если Django запущен за Nginx (в Docker), нужно доверять заголовкам прокси
if env.bool("USE_X_FORWARDED_HOST", default=True):
    SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")
    USE_X_FORWARDED_HOST = True
    USE_X_FORWARDED_PORT = True


# ==============================================================================
# APPLICATIONS
# ==============================================================================

INSTALLED_APPS = [
    # --- Встроенные приложения Django ---
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.postgres",  # Для GIN индексов и Trigram
    # --- Сторонние библиотеки ---
    "ninja",  # Быстрый API (FastAPI-like)
    "ninja_extra",  # База для контроллеров
    "ninja_jwt",  # JWT
    "ninja_jwt.token_blacklist",  # Черный список токенов
    "guardian",  # Объектные права доступа (Object Level Permissions)
    "axes",  # Защита от подбора паролей (brute-force protection)
    "corsheaders",  # CORS (для React)
    "pgtrigger",  # Триггеры для моделей
    "pghistory",  # Журнал изменений (Audit Log)
    # --- Приложения проекта Kronon ---
    "apps.common",  # Общие утилиты
    "apps.users",  # Пользователи, Отделы, Авторизация
    "apps.clients",  # Клиенты
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",  # Эффективная раздача статики
    "django.contrib.sessions.middleware.SessionMiddleware",
    "corsheaders.middleware.CorsMiddleware",  # Middleware для React
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "axes.middleware.AxesMiddleware",  # Middleware безопасности Axes
]

ROOT_URLCONF = "config.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        # Ищем шаблоны в корневой папке 'templates' и внутри приложений
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "config.wsgi.application"


# ==============================================================================
# AUTHENTICATION & SECURITY
# ==============================================================================

# Указываем Django использовать кастомную модель пользователя
AUTH_USER_MODEL = "users.User"

AUTHENTICATION_BACKENDS = [
    "axes.backends.AxesBackend",  # Защита от перебора паролей
    "django.contrib.auth.backends.ModelBackend",  # Стандартный вход
    "guardian.backends.ObjectPermissionBackend",  # Объектные права
]

# Валидаторы паролей TODO: усилить для прода
AUTH_PASSWORD_VALIDATORS = [
    {"NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"},
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator"},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]

# --- Admin credentials ---

ADMIN_EMAIL: str = env.str("ADMIN_EMAIL", default=None)
ADMIN_PASSWORD: str = env.str("ADMIN_PASSWORD", default=None)

# --- Настройки Ninja JWT ---

NINJA_JWT = {
    # Access токен живет 60 минут (достаточно для комфортной работы бухгалтера)
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=60),
    # Refresh токен живет 7 дней (чтобы не логиниться каждое утро, но и не вечно)
    "REFRESH_TOKEN_LIFETIME": timedelta(days=7),
    # При обновлении токена выдавать новый Refresh Token
    "ROTATE_REFRESH_TOKENS": True,
    # Заносить старый Refresh Token в черный список (чтобы его нельзя было украсть и использовать)
    "BLACKLIST_AFTER_ROTATION": True,
    # Не обновлять last_login при каждом запросе (экономит лишний запрос к БД в async режиме)
    "UPDATE_LAST_LOGIN": False,
    # Используем секретный ключ Django для подписи
    "ALGORITHM": "HS256",
    "SIGNING_KEY": SECRET_KEY,
    # Указываем, какое поле модели User использовать как ID в токене (UUID id)
    "USER_ID_FIELD": "id",
    "USER_ID_CLAIM": "user_id",
}

# --- Настройки Axes ---

# Количество неудачных попыток до блокировки
AXES_FAILURE_LIMIT = 5
# Время "остывания" после блокировки (10 минут)
AXES_COOLOFF_TIME = timedelta(minutes=10)
# Блокируем по комбинации IP + Username
AXES_LOCKOUT_PARAMETERS = ["ip_address", "username"]
# Логировать попытки входа в БД (полезно для аудита)
AXES_ENABLE_ACCESS_LOG = True

# Если Axes будет неправильно определять IP (всегда 127.0.0.1), раскомментировать эту строку
# AXES_CLIENT_IP_CALLABLE = "axes.handlers.proxy.get_client_ip_address"


# ==============================================================================
# DATABASE (PostgreSQL)
# ==============================================================================

# Проверка режима тестирования (стандарт для pytest-django)
TESTING: bool = "PYTEST_CURRENT_TEST" in os.environ

# Проверяем, нет ли готовой DATABASE_URL (Pytest/CI)
if env.str("DATABASE_URL", default=""):
    DATABASES = {"default": env.db_url("DATABASE_URL")}

else:
    # Cобираем URL подключения к БД
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.postgresql",
            "NAME": env.str("DB_NAME", default="kronon_db"),
            "USER": env.str("DB_USER", default="kronon_user"),
            "PASSWORD": env.str("DB_PASSWORD", default="secret_password"),
            "HOST": env.str("DB_HOST", default="db"),
            "PORT": env.int("DB_PORT", default=5432),
        }
    }

_DB_DEFAULT = DATABASES["default"]

# Определяем, работаем ли мы через PgBouncer (порт 6432)
# По умолчанию в коде — прямое соединение, PgBouncer прилетит из docker-compose.prod.yml
# Если порт 6432 — отключаем серверные курсоры, так как пулер работает в режиме транзакций (Transaction Pooling)
# В режиме разработки (порт 5432) и тестах (порт 5433) серверные курсоры будут включены для производительности
_CURRENT_PORT: int = int(_DB_DEFAULT.get("PORT", 5432))
_DB_DEFAULT["DISABLE_SERVER_SIDE_CURSORS"] = _CURRENT_PORT == 6432

# Оптимизация соединений (в тестах ставим 0, чтобы не плодить лишние коннекты)
_CONN_MAX_AGE = 0 if TESTING else env.int("CONN_MAX_AGE", default=60)
_DB_DEFAULT["CONN_MAX_AGE"] = _CONN_MAX_AGE


# ==============================================================================
# CACHE (Redis)
# ==============================================================================

# Приоритет: REDIS_URL из окружения (Docker/Pytest/CI) -> дефолт
_REDIS_BASE_URL: str = env.str("REDIS_URL", default="redis://redis:6379")

# Явно аннотируем тип переменной CACHES для mypy (Strict mode)
CACHES: dict[str, Any]

if TESTING:
    # Если это тесты, используем DummyCache, не мучаем Redis
    CACHES = {
        "default": {
            "BACKEND": "django.core.cache.backends.dummy.DummyCache",
        }
    }
else:
    # Основной кэш (база №1)
    CACHES = {
        "default": {
            "BACKEND": "django_redis.cache.RedisCache",
            # Используем базу №1 для кэша (чтобы не пересекаться с Celery)
            "LOCATION": f"{_REDIS_BASE_URL}/1",
            "OPTIONS": {
                "CLIENT_CLASS": "django_redis.client.DefaultClient",
                # Игнорировать ошибки подключения (сайт будет работать, но медленнее)
                "IGNORE_EXCEPTIONS": True,
            },
        }
    }

# Время жизни кэша по умолчанию (10 минут)
CACHE_TTL = 60 * 10


# ==============================================================================
# ASYNC TASKS (Celery)
# ==============================================================================

# URL брокера (по умолчанию база №2 в Redis, чтобы не пересекаться с кэшем)
CELERY_BROKER_URL: str = env.str("CELERY_BROKER_URL", default=f"{_REDIS_BASE_URL}/2")

# URL для хранения результатов выполнения задач (по умолчанию база №2 в Redis)
CELERY_RESULT_BACKEND: str = env.str("CELERY_RESULT_BACKEND", default=f"{_REDIS_BASE_URL}/2")

CELERY_TIMEZONE = "Europe/Minsk"
CELERY_TASK_TRACK_STARTED = True
CELERY_TASK_TIME_LIMIT = 30 * 60  # Максимум 30 минут на задачу


# ==============================================================================
# INTERNATIONALIZATION
# ==============================================================================

LANGUAGE_CODE = "ru-ru"
TIME_ZONE = "Europe/Minsk"
USE_I18N = True
USE_TZ = True

# Форматы ввода даты (DD.MM.YYYY - стандарт в РБ)
DATE_INPUT_FORMATS = [
    "%d.%m.%Y",  # 25.10.2025
    "%Y-%m-%d",  # 2025-10-25 (ISO)
]

# ==============================================================================
# STATIC & MEDIA FILES
# ==============================================================================

STATIC_URL = "static/"
STATIC_ROOT = BASE_DIR / "staticfiles"

# Директория для общих статических файлов (не внутри apps)
STATICFILES_DIRS = [
    BASE_DIR / "static",
]

# Whitenoise для сжатия и кэширования статики
STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"

# Медиа файлы (загрузки пользователей: сканы, отчеты)
MEDIA_URL = "media/"
MEDIA_ROOT = BASE_DIR / "media"


# ==============================================================================
# E-MAIL
# ==============================================================================

# E-mail настройки (Console для Dev, SMTP для Prod)
if DEBUG:
    EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"
else:
    EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"
    EMAIL_HOST: str = env.str("EMAIL_HOST", default="smtp.gmail.com")  # TODO: нужен реальный SMTP
    EMAIL_PORT: int = env.int("EMAIL_PORT", default=587)
    EMAIL_HOST_USER: str = env.str("EMAIL_HOST_USER", default="")
    EMAIL_HOST_PASSWORD: str = env.str("EMAIL_HOST_PASSWORD", default="")
    EMAIL_USE_TLS: bool = env.bool("EMAIL_USE_TLS", default=True)

# E-mail отправителя по умолчанию
DEFAULT_FROM_EMAIL: str = env.str("DEFAULT_FROM_EMAIL", default="noreply@kronon.by")


# ==============================================================================
# BUSINESS LOGIC SETTINGS & VALIDATION
# ==============================================================================

# Максимальный размер загружаемого изображения (в МБ)
MAX_IMAGE_SIZE_MB = 5
# Максимальный размер загружаемого документа (в МБ)
MAX_DOCUMENT_SIZE_MB = 20


# Регион для телефонов для парсинга номеров без кода страны (ISO 3166-1 alpha-2)
# 'BY' - Беларусь, 'RU' - Россия, 'KZ' - Казахстан
DEFAULT_PHONE_REGION = "BY"  # по умолчанию `Беларусь`


# ==============================================================================
# OTHERS
# ==============================================================================

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# Настройки для Guardian (анонимный пользователь не нужен)
ANONYMOUS_USER_NAME = None

# Настройки для PgHistory
PGHISTORY_OBJ_FIELD = "obj"  # Ссылка на объект в таблице истории


# ==============================================================================
# LOGURU & SENTRY CONFIGURATION
# ==============================================================================

# Отключаем стандартную конфигурацию Django logging, чтобы Loguru мог полностью управлять процессом
LOGGING_CONFIG = None
LOGGING: dict[str, Any] = {}

# Параметры логирования
LOG_LEVEL: str = env.str("LOG_LEVEL", default="INFO")
LOGFILE_SIZE: int = env.int("LOGFILE_SIZE", default=10)
LOGFILE_COUNT: int = env.int("LOGFILE_COUNT", default=5)

# Параметры Sentry
SENTRY_DSN: str | None = env.str("SENTRY_DSN", default=None)
SENTRY_ENVIRONMENT: str = env.str("SENTRY_ENVIRONMENT", default="production")


@dataclass
class KrononConfig:
    """
    Класс-контейнер для инициализации систем логирования и мониторинга.
    Удовлетворяет протоколам LoggingSettings и SentrySettings.
    """

    # Общие
    BASE_DIR: Path
    DEBUG: bool
    # Loguru
    LOG_LEVEL: str
    LOGFILE_SIZE: int
    LOGFILE_COUNT: int
    # Sentry
    SENTRY_DSN: str | None
    SENTRY_ENVIRONMENT: str


# Собираем конфиг
_config = KrononConfig(
    BASE_DIR=BASE_DIR,
    DEBUG=DEBUG,
    LOG_LEVEL=LOG_LEVEL,
    LOGFILE_SIZE=LOGFILE_SIZE,
    LOGFILE_COUNT=LOGFILE_COUNT,
    SENTRY_DSN=SENTRY_DSN,
    SENTRY_ENVIRONMENT=SENTRY_ENVIRONMENT,
)

# Инициализируем Loguru
setup_loguru(_config)

# Инициализируем Sentry
setup_sentry(_config)
